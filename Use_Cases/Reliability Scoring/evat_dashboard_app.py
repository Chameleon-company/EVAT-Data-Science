# -*- coding: utf-8 -*-
"""evat_dashboard_app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VE7093TJjrzjBTWaFeen6-lJ9Cpy2sJ9

# EVAT - Electric Vehicle Adoption Tools
### Streamlit Dashboard App
### Author: Dheepak SK | Capstone Team: Chameleon | Use Case: Reliability Scoring
"""



# ============================================================
# EVAT ‚Äì Charger Reliability & Sentiment Dashboard (v2)
# Fixes: last refresh metric + dynamic sentiment tables + smooth scrolling
# ============================================================

import base64
from pathlib import Path
from datetime import datetime

import numpy as np
import pandas as pd
import streamlit as st
import plotly.express as px
import folium
from streamlit_folium import st_folium

# ---------- Sentiment ----------
import nltk
from nltk.sentiment import SentimentIntensityAnalyzer
try:
    _ = nltk.data.find("sentiment/vader_lexicon.zip")
except LookupError:
    nltk.download("vader_lexicon")
sia = SentimentIntensityAnalyzer()

# ---------- Page ----------
st.set_page_config(page_title="EVAT ‚Äì Reliability & Sentiment", page_icon="‚ö°", layout="wide")

# ---------- Styles (dark EV theme + unlocked scroll) ----------
st.markdown("""
<style>
  html, body, .stApp, .main { background:#0e1117 !important; height:auto !important; overflow:auto !important; }
  .block-container { padding-top:.6rem; }
  h1,h2,h3,h4 { color:#25ffd0; font-weight:800; letter-spacing:.2px; }
  .card { background:#161a23; border:1px solid #2a3140; border-radius:14px; padding:1rem; box-shadow:0 6px 22px rgba(0,0,0,.45); }
  [data-testid="stMetric"]{ background:#161a23; border:1px solid #2a3140; border-radius:14px; padding:1.05rem; box-shadow:0 6px 22px rgba(0,0,0,.45); }
  [data-testid="stMetricLabel"] { color:#b6c8ff; font-weight:700; }
  [data-testid="stMetricValue"]{ color:#42ffd1; font-size:30px; font-weight:900;}
  .section { color:#d7e3ff; font-size:1.02rem; margin:.25rem 0 .35rem; display:flex; align-items:center; gap:.45rem;}
  .divider { height:1px; width:100%; background:linear-gradient(90deg,transparent,#283141,transparent); margin:18px 0; }
  .stSelectbox > div, .stTextInput > div, .stNumberInput > div { background:#161a23 !important; border:1px solid #2a3140 !important; color:#eaf2ff !important; border-radius:10px !important; }
  .stDataFrame thead th { background:#151b25 !important; color:#eaf2ff !important; }
</style>
""", unsafe_allow_html=True)

def hero(img_url: str):
    st.markdown(f"""
    <div class="card" style="
         display:flex; gap:22px; align-items:center; justify-content:space-between;
         background: radial-gradient(1200px 320px at 20% -40%, rgba(0,255,204,.15), transparent 60%),
                     linear-gradient(135deg, #111622 0%, #0e1117 35%, #0e1117 100%);">
      <div style="flex:1; min-width:260px;">
        <div style="color:#8db2ff; font-weight:700; letter-spacing:.12rem; text-transform:uppercase; font-size:.78rem;">EVAT</div>
        <div style="font-size:32px; font-weight:900; color:#25ffd0; line-height:1.15; margin:.2rem 0 .5rem;">
          Charger Reliability & Sentiment Dashboard
        </div>
        <div style="color:#d7e3ff; font-size:14.5px; opacity:.92;">
          Melbourne coverage ‚Ä¢ Real-world reliability metrics ‚Ä¢ User sentiment ranking
        </div>
      </div>
      <div style="flex:1; min-width:280px; display:flex; justify-content:flex-end;">
        <img src="{img_url}" style="width:100%; max-width:560px;" alt="EV">
      </div>
    </div>
    """, unsafe_allow_html=True)

def polish(fig, tpad=40):
    fig.update_layout(template="plotly_dark",
                      paper_bgcolor="rgba(0,0,0,0)", plot_bgcolor="rgba(0,0,0,0)",
                      font=dict(color="#eaf2ff", size=14, family="Inter, system-ui, Segoe UI, Roboto"),
                      title_font=dict(color="#eaf2ff", size=16, family="Inter, system-ui, Segoe UI, Roboto"),
                      margin=dict(l=10, r=10, t=tpad, b=10))
    fig.update_xaxes(color="#eaf2ff", gridcolor="#283141")
    fig.update_yaxes(color="#eaf2ff", gridcolor="#283141")
    return fig

def first_col(df: pd.DataFrame, *cands) -> str:
    for c in cands:
        if c in df.columns:
            return c
    raise KeyError(f"Missing columns from {cands}")

@st.cache_data(show_spinner=False)
def load_data(csv="EVAT-Final-Enriched.csv"):
    # capture load time
    loaded_at = datetime.now()

    df = pd.read_csv(csv)

    # Flexible column resolution
    col_uptime   = first_col(df, "Uptime_%", "Uptime (%)", "uptime_percent", "Uptime")
    col_downtime = first_col(df, "Downtime_%", "Downtime (%)", "downtime_percent", "Downtime")
    col_status   = first_col(df, "Status", "status")
    col_name     = first_col(df, "Charger Name", "Charger_Name", "charger_name")
    col_id       = first_col(df, "Charger ID", "Charger_ID", "charger_id")
    col_lat      = first_col(df, "latitude", "Latitude", "lat")
    col_lon      = first_col(df, "longitude", "Longitude", "lon", "lng")
    col_rel      = first_col(df, "reliability_score", "Reliability", "Reliability_Score")
    col_fb       = first_col(df, "User_Feedback", "User Feedback", "User Comment", "User_Comment")
    col_rating   = first_col(df, "Rating", "User Rating", "User_Rating")
    col_suburb   = first_col(df, "Suburb", "suburb")
    col_last     = first_col(df, "Last_Checked", "Last Checked", "last_checked")

    # Types
    for c in [col_uptime, col_downtime, col_rel, col_rating, col_lat, col_lon]:
        df[c] = pd.to_numeric(df[c], errors="coerce")
    df[col_last] = pd.to_datetime(df[col_last], errors="coerce")
    df[col_fb] = df[col_fb].fillna("").astype(str).str.strip()

    # Normalize names
    df = df.rename(columns={
        col_uptime:   "Uptime_%",
        col_downtime: "Downtime_%",
        col_status:   "Status",
        col_name:     "Charger_Name",
        col_id:       "Charger_ID",
        col_lat:      "latitude",
        col_lon:      "longitude",
        col_rel:      "reliability_score",
        col_fb:       "User_Feedback",
        col_rating:   "Rating",
        col_suburb:   "Suburb",
        col_last:     "Last_Checked",
    })

    # Sentiment with ¬±0.2 thresholds (more forgiving)
    def lab(text: str):
        if not text or text.lower() in {"na","n/a","none","nan"}:
            return 0.0, "Neutral"
        comp = sia.polarity_scores(text)["compound"]
        if comp >= 0.2:  labl = "Positive"
        elif comp <= -0.2: labl = "Negative"
        else: labl = "Neutral"
        return comp, labl

    parsed = df["User_Feedback"].apply(lab)
    df["Sentiment_Score"] = parsed.apply(lambda x: x[0])
    df["Sentiment_Label"] = parsed.apply(lambda x: x[1])

    return df, loaded_at

# ---------- Data ----------
df, loaded_at = load_data()

# ---------- Hero ----------
st.markdown("### ‚ö° Uptime vs Downtime Trends")
hero("https://raw.githubusercontent.com/streamlit/example-data/main/uber-nyc-pickups/uber.png")
st.markdown('<div class="divider"></div>', unsafe_allow_html=True)

# ========== FILTERS ==========
c1, c2, c3 = st.columns([1,1,0.7])
with c1:
    st.markdown('<div class="section">üìç Suburb</div>', unsafe_allow_html=True)
    suburbs = ["All"] + sorted(df["Suburb"].dropna().unique().tolist())
    f_suburb = st.selectbox("Suburb", suburbs, index=0, label_visibility="collapsed")
with c2:
    st.markdown('<div class="section">üß† Sentiment</div>', unsafe_allow_html=True)
    sentiments = ["All","Positive","Neutral","Negative"]
    f_sent = st.selectbox("Sentiment", sentiments, index=0, label_visibility="collapsed")
with c3:
    st.markdown('<div class="section">‚öôÔ∏è Options</div>', unsafe_allow_html=True)
    show_debug = st.toggle("Show label counts", value=False)

# Apply suburb first
filtered = df.copy()
if f_suburb != "All":
    filtered = filtered[filtered["Suburb"] == f_suburb]

# Debug counts in scope
counts_scope = (filtered["Sentiment_Label"].value_counts()
                .reindex(["Positive","Neutral","Negative"]).fillna(0).astype(int))
if show_debug:
    st.info(f"Scope counts ‚Üí Positive: {counts_scope['Positive']}, Neutral: {counts_scope['Neutral']}, Negative: {counts_scope['Negative']}")

# Apply sentiment filter next
if f_sent != "All":
    filtered = filtered[filtered["Sentiment_Label"].str.lower() == f_sent.lower()]

# ========== KPIs ==========
total_stations = int(filtered["Charger_ID"].nunique() if "Charger_ID" in filtered.columns else len(filtered))
online_pct = round(100*(filtered["Status"].str.lower().eq("online").mean() if not filtered.empty else 0), 1)
avg_uptime = round(filtered["Uptime_%" ].mean(skipna=True), 1) if not filtered.empty else 0.0
avg_rel    = round(filtered["reliability_score"].mean(skipna=True), 1) if not filtered.empty else 0.0

# robust "last refresh": prefer dataset's Last_Checked max, else file mtime, else load time
last_checked = df["Last_Checked"].max()
if pd.isna(last_checked):
    # try file mtime
    csv_path = Path("EVAT-Final-Enriched.csv")
    if csv_path.exists():
        last_checked = datetime.fromtimestamp(csv_path.stat().st_mtime)
    else:
        last_checked = loaded_at
last_ref_str = last_checked.strftime("%Y-%m-%d %H:%M")
# Always show current system time as last refresh
last_ref_str = datetime.now().strftime("%Y-%m-%d %H:%M")



m1, m2, m3, m4, m5 = st.columns([1,1,1,1,1])
with m1: st.metric("‚ö° Total Stations", total_stations)
with m2: st.metric("üü¢ Online %", f"{online_pct}%")
with m3: st.metric("üìà Avg Uptime", f"{avg_uptime}%")
with m4: st.metric("‚≠ê Avg Reliability", f"{avg_rel}")
with m5: st.metric("üïí Last refresh", last_ref_str)

st.markdown('<div class="divider"></div>', unsafe_allow_html=True)

# ========== MAP ==========
st.markdown('<div class="section">üó∫Ô∏è Charger Locations</div>', unsafe_allow_html=True)

center_lat = (filtered["latitude"].median() if not filtered["latitude"].dropna().empty else -37.8136)
center_lon = (filtered["longitude"].median() if not filtered["longitude"].dropna().empty else 144.9631)

m = folium.Map(location=[center_lat, center_lon], zoom_start=10, tiles="CartoDB dark_matter")

def icon_color(row):
    if str(row.get("Status","")).lower() == "online":
        return "green" if row.get("Sentiment_Label") != "Negative" else "orange"
    return "red"

for _, r in filtered.dropna(subset=["latitude","longitude"]).iterrows():
    folium.Marker(
        [r["latitude"], r["longitude"]],
        tooltip=r.get("Charger_Name","Charger"),
        icon=folium.Icon(color=icon_color(r)),
        popup=folium.Popup(f"""
          <div style='font-family:Inter; font-size:13px; color:#0a0a0a;'>
            <b>{r.get('Charger_Name','Charger')}</b><br/>
            {r.get('Address','')} {r.get('Suburb','')}<br/>
            <b>Status:</b> {r.get('Status','')}<br/>
            <b>Reliability:</b> {r.get('reliability_score',np.nan)}<br/>
            <b>Uptime:</b> {r.get('Uptime_%',np.nan)}%<br/>
            <b>Sentiment:</b> {r.get('Sentiment_Label','')}<br/>
            <b>Feedback:</b> {str(r.get('User_Feedback',''))[:160] + ('...' if len(str(r.get('User_Feedback',''))) > 160 else '')}
          </div>
        """, max_width=320)
    ).add_to(m)

st_folium(m, width=None, height=520)
st.markdown('<div class="divider"></div>', unsafe_allow_html=True)

# ========== ANALYTICS ==========
left, right = st.columns(2)

with left:
    st.markdown('<div class="section">üìä Uptime vs Downtime (filtered)</div>', unsafe_allow_html=True)
    if filtered.empty or filtered["Uptime_%"].dropna().empty or filtered["Downtime_%"].dropna().empty:
        st.info("No data for current filters.")
    else:
        fig1 = px.scatter(filtered, x="Uptime_%", y="Downtime_%", color="Status",
                          hover_data=["Charger_Name","Suburb","Sentiment_Label"], title="Charger Uptime vs Downtime")
        st.plotly_chart(polish(fig1), use_container_width=True)

with right:
    st.markdown('<div class="section">üìà Reliability Score Distribution (filtered)</div>', unsafe_allow_html=True)
    if filtered.empty or filtered["reliability_score"].dropna().empty:
        st.info("No data for current filters.")
    else:
        fig2 = px.histogram(filtered, x="reliability_score", nbins=20, title="Reliability score distribution")
        st.plotly_chart(polish(fig2), use_container_width=True)

# ========== SENTIMENT ==========
st.markdown('<div class="section">üíö Sentiment Overview</div>', unsafe_allow_html=True)
colA, colB = st.columns([1,1])

with colA:
    # pie reflects *something* even if the table scope is empty
    scope_df = filtered if not filtered.empty else df if f_suburb == "All" else df[df["Suburb"] == f_suburb]
    if scope_df.empty:
        st.info("No feedback for current filters.")
    else:
        pie_df = scope_df["Sentiment_Label"].value_counts().rename_axis("Sentiment").reset_index(name="Count")
        fig_pie = px.pie(
            pie_df, names="Sentiment", values="Count", hole=0.5, title="Feedback sentiment",
            color="Sentiment",
            color_discrete_map={"Positive":"#00C49A","Neutral":"#FFBF00","Negative":"#FF4D4F"}
        )
        fig_pie.update_traces(textinfo="percent+label")
        st.plotly_chart(polish(fig_pie), use_container_width=True)

with colB:
    # dynamic sentiment table based on dropdown
    if filtered.empty:
        st.info("No rows for current sentiment/suburb filters.")
    else:
        if f_sent == "Positive":
            tmp = filtered.copy()
            tmp["rank_key"] = tmp["Sentiment_Score"].fillna(0)*1000 + tmp["Rating"].fillna(0)
            show = tmp.sort_values("rank_key", ascending=False).head(5)
            title = "üèÜ Top 5 Positive Chargers"
        elif f_sent == "Negative":
            tmp = filtered.copy()
            tmp["rank_key"] = tmp["Sentiment_Score"].fillna(0)*1000 - tmp["reliability_score"].fillna(0)
            show = tmp.sort_values("rank_key", ascending=True).head(5)  # most negative first
            title = "üö´ Top 5 Negative Chargers"
        elif f_sent == "Neutral":
            tmp = filtered.copy()
            tmp["abs0"] = tmp["Sentiment_Score"].abs()
            show = tmp.sort_values(["abs0","reliability_score"], ascending=[True, False]).head(10)
            title = "üòê Top 10 Neutral (closest to 0)"
        else:
            # f_sent == "All" ‚Üí highlight the best positives anyway (nice default)
            tmp = filtered.copy()
            tmp_pos = tmp[tmp["Sentiment_Label"]=="Positive"].copy()
            if tmp_pos.empty:
                st.info("No positive rows in current scope. Use the table below for full list.")
                show = pd.DataFrame()
                title = "No Positive Rows"
            else:
                tmp_pos["rank_key"] = tmp_pos["Sentiment_Score"].fillna(0)*1000 + tmp_pos["Rating"].fillna(0)
                show = tmp_pos.sort_values("rank_key", ascending=False).head(5)
                title = "üèÜ Top 5 Positive Chargers"

        st.markdown(f"**{title}**")
        if show.empty:
            st.info("Nothing to show for this selection.")
        else:
            show_cols = ["Charger_Name","Suburb","Status","Rating","reliability_score","Uptime_%","Sentiment_Score","User_Feedback"]
            st.dataframe(show[[c for c in show_cols if c in show.columns]], use_container_width=True, height=260)

st.markdown('<div class="divider"></div>', unsafe_allow_html=True)

# ========== TABLE (always respects filters) ==========
st.markdown('<div class="section">üßæ Station list (respects filters)</div>', unsafe_allow_html=True)
table_cols = ["Charger_ID","Charger_Name","Suburb","Status","Uptime_%","Downtime_%","reliability_score","Rating",
              "Sentiment_Label","Sentiment_Score","User_Feedback","latitude","longitude","Last_Checked"]
exists = [c for c in table_cols if c in filtered.columns]
if filtered.empty:
    st.dataframe(pd.DataFrame(columns=exists), use_container_width=True, height=280)
else:
    st.dataframe(
        filtered[exists].sort_values(
            ["Sentiment_Label","reliability_score","Uptime_%"], ascending=[True,False,False]
        ),
        use_container_width=True, height=420
    )

st.caption(f"Last updated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} ‚Ä¢ Filters ‚Üí Suburb: {f_suburb} | Sentiment: {f_sent}")